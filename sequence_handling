#!/bin/bash

set -o pipefail

function Usage() {
    echo -e "\
Usage:  `basename $0` <handler> Config \n\
Where:  <handler> is one of: \n\
            1 | Quality_Assessment \n\
            2 | Read_Depths \n\
            3 | Adapter_Trimming \n\
            4 | Quality_Trimming \n\
            5 | Read_Mapping \n\
            6 | SAM_Processing \n\
            7 | Coverage_Mapping \n\
            8 | Indel_Realignment \n\
And:    Config is the full file path to the configuration file
" >&2
    exit 1
}

export -f Usage

#   Where is 'sequence_handling' located?
# SEQUENCE_HANDLING=`dirname "$0"`
SEQUENCE_HANDLING=`pwd -P`

#   If we have less than two arguments
if [[ "$#" -lt 1 ]]; then Usage; fi # Display the usage message and exit

ROUTINE="$1" # What routine are we running?
CONFIG="$2" # Where is our config file?

#   If the specified config exists
if [[ -f "${CONFIG}" ]]
then
    source "${CONFIG}" # Source it, providing parameters and software
    bash "${CONFIG}" > /dev/null 2> /dev/null # Load any modules
    source "${SEQUENCE_HANDLING}"/HelperScripts/utils.sh # And the utils script
else # If it doesn't
    echo "Please specify a valid config file." >&2 # Print error message
    exit 1 # Exit with non-zero exit status
fi

#   Run sequence_handling
case "${ROUTINE}" in
    1|Quality_Assessment)
        echo "$(basename $0): Assessing quality..." >&2
        source "${SEQUENCE_HANDLING}"/Handlers/Assess_Quality.sh
        checkDependencies Assess_Quality_Dependencies[@] # Check to see if dependencies are installed
        if [[ "$?" -ne 0 ]]; then exit 1; fi # If we're missing a dependency, exit out with error
        checkSamples "${RAW_SAMPLES}" # Check to see if samples and sample list exists
        if [[ "$?" -ne 0 ]]; then exit 1; fi # If we're missing a sample or our list, exit out with error
        #   Run Quality_Assessment
        echo "source ${CONFIG} && source ${SEQUENCE_HANDLING}/Handlers/Assess_Quality.sh && Assess_Quality ${RAW_SAMPLES} ${OUT_DIR} ${PROJECT}" | qsub -l "${QA_QSUB}" -m abe -M "${EMAIL}" -N "${PROJECT}"_Quality_Assessment
        ;;
    2|Read_Depths)
        echo "$(basename $0): Calculating coverage and read counts..." >&2
        source "${SEQUENCE_HANDLING}"/Handlers/Read_Depths.sh
        checkDependencies Read_Depths_Dependencies[@] # Check to see if dependencies are installed
        if [[ "$?" -ne 0 ]]; then exit 1; fi # If we're missing a dependency, exit out with error
        checkSamples "${RAW_SAMPLES}" # Check to see if samples and sample list exists
        checkSamples "${ZIP_FILES}" # Check to see if zipfiles and list exist
        #   Run Read_Depths
        echo "source ${CONFIG} && source ${SEQUENCE_HANDLING}/Handlers/Read_Depths.sh && Read_Depths ${RAW_SAMPLES} ${ZIP_FILES} ${OUT_DIR} ${PROJECT} ${TARGET}" | qsub -l "${RD_QSUB}" -m abe -M "${EMAIL}" -N "${PROJECT}"_Read_Depths
        ;;
    3|Adapter_Trimming )
        echo "$(basename $0): Trimming adapters..." >&2
        source "${SEQUENCE_HANDLING}"/Handlers/Adapter_Trimming.sh
        checkDependencies Adapter_Trimming_Dependencies[@] # Check to see if dependencies are installed
        if [[ "$?" -ne 0 ]]; then exit 1; fi # If we're missing a dependency, exit out with error
        checkSamples "${RAW_SAMPLES}" # Check to see if samples and sample list exists
        if [[ "$?" -ne 0 ]]; then exit 1; fi # If we're missing a sample or our list, exit out with error
        if ! [[ -f "${ADAPTERS}" ]]; then echo "Please specify a valid adapters file" >&2; exit 1; fi # Check for a valid adapters file
        #   Run Adapter_Trimming
        echo "source ${CONFIG} && source ${SEQUENCE_HANDLING}/Handlers/Adapter_Trimming.sh && Adapter_Trimming ${RAW_SAMPLES} ${OUT_DIR} ${PROJECT} ${FORWARD_NAMING} ${REVERSE_NAMING} ${ADAPTERS} ${PRIOR} ${PLATFORM}" | qsub -l "${AT_QSUB}" -m abe -M "${EMAIL}" -N "${PROJECT}"_Adapter_Trimming
        ;;
    4|Quality_Trimming )
        echo "$(basename $0): Trimming based on quality..." >&2
        source "${SEQUENCE_HANDLING}"/Handlers/Quality_Trimming.sh
        checkDependencies Quality_Trimming_Dependencies[@] # Check to see if dependencies are installed
        if [[ "$?" -ne 0 ]]; then exit 1; fi # If we're missing a dependency, exit out with error
        checkSamples "${ADAPTED_LIST}" # Check to see if samples and sample list exists
        if [[ "$?" -ne 0 ]]; then exit 1; fi # If we're missing a sample or our list, exit out with error
        #   Run Quality_Trimming
        echo "source ${CONFIG} && source ${SEQUENCE_HANDLING}/Handlers/Quality_Trimming.sh && Quality_Trimming ${ADAPTED_LIST} ${FORWARD_ADAPTED} ${REVERSE_ADAPTED} ${SINGLES_ADAPTED} ${OUT_DIR} ${THRESHOLD} ${PLATFORM} ${SEQUENCE_HANDLING} ${PROJECT}"| qsub -l "${QT_QSUB}" -m abe -M "${EMAIL}" -N "${PROJECT}"_Quality_Trimming
        ;;
    5|Read_Mapping )
        echo "`basename $0`: Mapping reads...">&2
        source "${SEQUENCE_HANDLING}"/Handlers/Read_Mapping.sh
        checkDependencies Read_Mapping_Dependencies[@] # Check to see if dependencies are installed
        if [[ "$?" -ne 0 ]]; then exit 1; fi # If we're missing a dependency, exit out with error
        checkSamples "${TRIMMED_LIST}" # Check to see if samples and sample list exists
        if [[ "$?" -ne 0 ]]; then exit 1; fi # If we're missing a sample or our list, exit out with error
        checkIndex "${REF_GEN}" # Check to make sure our reference genome is indexed
        if [[ "$?" -ne 0 ]]; then echo "Reference genome is not indexed for BWA mem..." >&2; indexReference "${REF_GEN}"; fi # If not, index it and exit
        declare -a SINGLE_SAMPLES=($(grep -E "${SINGLES_TRIMMED}" "${TRIMMED_LIST}")) # Get the single-end samples
        declare -a FORWARD_SAMPLES=($(grep -E "${FORWARD_TRIMMED}" "${TRIMMED_LIST}")) # Get the forward samples
        declare -a REVERSE_SAMPLES=($(grep -E "${REVERSE_TRIMMED}" "${TRIMMED_LIST}")) # Get the reverse samples
        if ! [[ -z "${SINGLE_SAMPLES[@]}" ]] # If we have single-end samples
        then
            declare -a SINGLE_NAMES=($(parallel basename {} "${SINGLES_TRIMMED}" ::: "${SINGLE_SAMPLES[@]}")) # Create an array of single-end sample names
            SINGLE_ARRAY_LIMIT=$[${#SINGLE_NAMES[@]} - 1] # Get the maximum number of Torque tasks we're doing for single-end samples
            #   Run Read_Mapping for single-end smaples
            echo -e "#!/bin/bash\n#PBS -l ${RM_QSUB}\n#PBS -m abe\n#PBS -M ${EMAIL}\nset -e\nset -o pipefail\nsource ${CONFIG}\nsource ${SEQUENCE_HANDLING}/Handlers/Read_Mapping.sh\ndeclare -a SINGLE_SAMPLES=(\$(grep -E "${SINGLES_TRIMMED}" "\${TRIMMED_LIST}"))\ndeclare -a SINGLE_NAMES=(\$(parallel basename {} "${SINGLES_TRIMMED}" ::: "\${SINGLE_SAMPLES[@]}"))\nSINGLE_ARRAY_LIMIT=\$[\${#SINGLE_NAMES[@]} - 1]\nRead_Mapping_Singles \${SINGLE_NAMES[\${PBS_ARRAYID}]} \${SINGLE_SAMPLES[\${PBS_ARRAYID}]} ${PROJECT} ${PLATFORM} ${OUT_DIR} ${REF_GEN}" > ${PROJECT}_Read_Mapping_Single
            qsub -t 0-"${SINGLE_ARRAY_LIMIT}" "${PROJECT}"_Read_Mapping_Single
        fi
        if [[ ! -z "${FORWARD_SAMPLES[@]}" && ! -z "${REVERSE_SAMPLES[@]}" ]] # If we have paired-end samples
        then
            if [[ "${#FORWARD_SAMPLES[@]}" -ne "${#REVERSE_SAMPLES[@]}" ]]; then echo "Unequal numbers of forward and reverse reads, exiting..." >&2; exit 1; fi # Make sure we have equal numbers of forward and reverse samples
            declare -a PAIRED_NAMES=($(parallel basename {} "${FORWARD_TRIMMED}" :::  "${FORWARD_SAMPLES[@]}")) # Create an array of paired-end sample names
            PAIRED_ARRAY_LIMIT=$[${#PAIRED_NAMES[@]} - 1] # Get the maximum number of Torque tasks we're doing for single-end samples
            #   Run Read_Mapping for paired-end samples
            echo -e "#!/bin/bash\n#PBS -l ${RM_QSUB}\n#PBS -m abe\n#PBS -M ${EMAIL}\nset -e\nset -o pipefail\nsource ${CONFIG}\nsource ${SEQUENCE_HANDLING}/Handlers/Read_Mapping.sh\ndeclare -a FORWARD_SAMPLES=(\$(grep -E "${FORWARD_TRIMMED}" "\${TRIMMED_LIST}"))\ndeclare -a REVERSE_SAMPLES=(\$(grep -E "${REVERSE_TRIMMED}" "\${TRIMMED_LIST}"))\ndeclare -a PAIRED_NAMES=(\$(parallel basename {} "${FORWARD_TRIMMED}" :::  "\${FORWARD_SAMPLES[@]}"))\nPAIRED_ARRAY_LIMIT=\$[\${#PAIRED_NAMES[@]} - 1]\nRead_Mapping_Paired \${PAIRED_NAMES[\${PBS_ARRAYID}]} \${FORWARD_SAMPLES[\${PBS_ARRAYID}]} \${REVERSE_SAMPLES[\${PBS_ARRAYID}]} ${PROJECT} ${PLATFORM} ${OUT_DIR} ${REF_GEN}" > "${PROJECT}"_Read_Mapping_Paired
            qsub -t 0-"${PAIRED_ARRAY_LIMIT}" "${PROJECT}"_Read_Mapping_Paired
        fi
        ;;
    6|SAM_Processing )
        case "${METHOD}" in
        samtools )
            echo "$(basename $0): Processing SAM files..." >&2
            source "${SEQUENCE_HANDLING}"/Handlers/SAM_Processing_SAMtools.sh
            checkDependencies SAM_Processing_Dependencies[@] # Check to see if the dependencies are installed
            if [[ "$?" -ne 0 ]]; then exit 1; fi # If we're missing a dependency, exit out with error
            SAM_LIST=$(findMappedSAM "${MAPPED_DIRECTORY}" "${PROJECT}")
            checkSamples "${SAM_LIST}" # Check to see if samples and sample list exists
            if [[ "$?" -ne 0 ]]; then exit 1; fi # If we're missing a sample or our list, exit out with error
            checkFaidx "${REF_GEN}" # Check to see if reference genome is indexed
            if [[ "$?" -ne 0 ]]; then echo "Reference genome is not indexed for SAM Processing...">&2; fadixReference "${REF_GEN}"; fi # If not, index and exit
            #   Run SAM_Processing
            echo "source ${CONFIG} && source ${SEQUENCE_HANDLING}/Handlers/SAM_Processing_SAMtools.sh && SAM_Processing ${SAM_LIST} ${OUT_DIR} ${REF_GEN} ${PROJECT}" | qsub -l "${SP_QSUB}" -m abe -M "${EMAIL}" -N "${PROJECT}"_SAM_Processing
            ;;
        picard )
            echo "$(basename $0): Processing SAM files..." >&2
            source "${SEQUENCE_HANDLING}"/Handlers/SAM_Processing_Picard.sh
            checkDependencies SAM_Processing_Dependencies[@] # Check to see if the dependencies are installed
            if [[ "$?" -ne 0 ]]; then exit 1; fi # If we're missing a dependency, exit out with error
            SAM_LIST_NAME=$(findMappedSAM "${MAPPED_DIRECTORY}" "${PROJECT}")
            checkSamples "${SAM_LIST_NAME}" # Check to see if samples and sample list exists
            if [[ "$?" -ne 0 ]]; then exit 1; fi # If we're missing a sample or our list, exit out with error
            checkPicard "${PICARD_JAR}" # Check to make sure Picard is installed
            if [[ "$?" -ne 0 ]]; then exit 1; fi # If we don't have Picard, exit with error
            # Run SAM_Processing using a task array
            declare -a SAM_LIST=($(grep -E ".sam" "${SAM_LIST_NAME}"))
            SINGLE_ARRAY_LIMIT=$[${#SAM_LIST[@]} - 1] # Get the maximum number of Torque tasks we're doing for SAM samples
            echo -e "#!/bin/bash\n#PBS -l ${SP_QSUB}\n#PBS -m abe\n#PBS -M ${EMAIL}\nset -e\nset -o pipefail\nsource ${CONFIG}\nsource ${SEQUENCE_HANDLING}/Handlers/SAM_Processing_Picard.sh\ndeclare -a SAM_LIST=($(grep -E ".sam" "${SAM_LIST_NAME}"))\nSINGLE_ARRAY_LIMIT=\$[\${#SAM_LIST[@]} - 1]\nSAM_Processing \${SAM_LIST[\${PBS_ARRAYID}]} ${OUT_DIR} ${PICARD_JAR} ${PLATFORM} ${MAX_MEM} ${MAX_FILES} ${TMP}" > ${PROJECT}_SAM_Processing
            qsub -t 0-"${SINGLE_ARRAY_LIMIT}" "${PROJECT}"_SAM_Processing
            ;;
        * )
            echo "Invalid method"
            exit 1
            ;;
        esac
        ;;
    7|Coverage_Mapping )
        echo "$(basename $0): Mapping coverage..." >&2
        source "${SEQUENCE_HANDLING}"/Handlers/Coverage_Mapping.sh
        checkDependencies Coverage_Mapping_Dependencies[@] # Check to see if the dependencies are installed
        if [[ "$?" -ne 0 ]]; then exit 1; fi # If we're missing a dependency, exit out with error
        checkSamples "${BAM_SAMPLES}" # Check to see if samples and sample list exists
        if [[ "$?" -ne 0 ]]; then exit 1; fi # If we're missing a sample or our list, exit out with error
        if ! [[ -f "${REF_ANN}" ]]; then echo "Failed to find reference annotation file, exiting..." >&2; exit 1; fi # Check to see if the reference annotation file exists. If not, exit
        #   Run Coverage_Mapping
        echo "source ${CONFIG} && source ${SEQUENCE_HANDLING}/Handlers/Coverage_Mapping.sh && Coverage_Mapping ${BAM_SAMPLES} ${OUT_DIR} ${REF_ANN} ${SEQUENCE_HANDLING}"  | qsub -l "${CM_QSUB}" -m abe -M "${EMAIL}" -N "${PROJECT}"_Coverage_Mapping
        ;;
    8|Indel_Realignment )
        echo "$(basename $0): Realigning reads near indels..." >&2
        source "${SEQUENCE_HANDLING}"/Handlers/Indel_Realignment.sh
        checkDependencies Indel_Realignment_Dependencies[@] # Check to see if the dependencies are installed
        if [[ "$?" -ne 0 ]]; then exit 1; fi # If we're missing a dependency, exit out with error
        BAM_LIST_NAME=$(findProcessedBAM "${BAM_DIRECTORY}" "${PROJECT}")
        checkSamples "${BAM_LIST_NAME}" # Check to see if samples and sample list exists
        if [[ "$?" -ne 0 ]]; then exit 1; fi # If we're missing a sample or our list, exit out with error
        checkGATK "${GATK_JAR}" # Check to make sure GATK is installed
        if [[ "$?" -ne 0 ]]; then exit 1; fi # If we don't have GATK, exit with error
        echo "source ${CONFIG} && source ${SEQUENCE_HANDLING}/Handlers/Indel_Realignment.sh && Indel_Realignment ${BAM_LIST_NAME} ${OUT_DIR} ${GATK_JAR} ${REF_GEN} ${KNOWN_INDELS} ${MODEL} ${LOG_ODDS} ${MAX_MEMORY} ${PROJECT} ${TARGET_INTERVALS}" | qsub -l "${IR_QSUB}" -m abe -M "${EMAIL}" -N "${PROJECT}"_Indel_Realignment
        ;;
    * )
        Usage
        ;;
esac
